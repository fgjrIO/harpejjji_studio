<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Harpejji Tablature Emulation (Plain JS + Tailwind)</title>
  <!-- Tailwind CSS (via CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 min-h-screen p-4">
<div class="max-w-5xl mx-auto bg-white rounded shadow p-4">
  <h1 class="text-2xl font-bold mb-4">Harpejji® Tablature (Plain JS)</h1>

  <!-- Controls -->
  <div class="flex flex-wrap items-center gap-4 mb-4">
    <!-- NEW: Model dropdown -->
    <div class="flex items-center gap-2">
      <label for="modelSelect" class="text-gray-700">Model:</label>
      <select 
        id="modelSelect"
        class="px-3 py-2 rounded border border-gray-300 bg-white focus:border-blue-500 focus:ring-1 focus:ring-blue-500 focus:outline-none min-w-[200px]"
      >
        <option value="K24">K24 (A0 → A5, 24 strings)</option>
        <option value="G16">G16 (E2 → C6, 16 strings)</option>
        <option value="G12">G12 (C2 → G#5, 12 strings)</option>
      </select>
    </div>

    <button 
      id="toggleNotesBtn"
      class="px-4 py-2 rounded bg-blue-500 text-white hover:bg-blue-600"
    >
      Toggle Note Names
    </button>

    <button 
      id="resetMarkersBtn"
      class="px-4 py-2 rounded bg-red-500 text-white hover:bg-red-600"
    >
      Clear All Markers
    </button>

    <span class="text-gray-600 text-sm">
      Click any key to toggle a marker and play its note.
    </span>
  </div>

  <!-- Our Tablature SVG -->
  <svg 
    id="tablature" 
    class="border border-gray-400"
  >
    <!-- Dynamically drawn via JS -->
  </svg>
</div>

<script>
/**
 * Harpejji® Tablature Demo (Plain JS + Tailwind)
 *
 * Key changes from your original code:
 *  1) A dropdown to select K24 / G16 / G12.
 *  2) The bottom row is physically at the bottom (row=0 at bottom),
 *     top row is physically at the top (row=numberOfFrets-1 at top).
 *  3) The bottom-left is labeled "start note," top-right "end note."
 *  4) Everything else (colors, widths, lines) is the same as your snippet.
 */

// === Models ===
const MODELS = {
  K24: {
    numberOfStrings: 24,  // left-to-right
    numberOfFrets:   15,  // bottom-to-top
    startNote:  "A",
    startOctave: 0, // A0
    endNote:    "A",
    endOctave:  5  // A5
  },
  G16: {
    numberOfStrings: 16,
    numberOfFrets:   15,
    startNote:  "E",
    startOctave: 2, // E2
    endNote:    "C",
    endOctave:  6  // C6
  },
  G12: {
    numberOfStrings: 12,
    numberOfFrets:   15,
    startNote:  "C",
    startOctave: 2, // C2
    endNote:    "G#",
    endOctave:  5  // G#5
  }
};

// Layout constants (same as your original)
const fretSpacing   = 30; 
const stringSpacing = 30; 
const keyHeight     = 25; 

// Chromatic scale
const NOTES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];

// Default: K24
let currentModel = MODELS.K24;
let numberOfStrings = currentModel.numberOfStrings;
let numberOfFrets   = currentModel.numberOfFrets;
let BASE_NOTE       = currentModel.startNote;
let BASE_OCTAVE     = currentModel.startOctave;

// Determine SVG dimension from current model
let svgWidth  = stringSpacing * (numberOfStrings + 2);
let svgHeight = fretSpacing   * (numberOfFrets   + 2);

// Keep track of markers
let keysState = [];

// Initialize keysState for the current board
function initKeysState() {
  keysState = [];
  for (let y = 0; y < numberOfFrets; y++) {
    keysState[y] = [];
    for (let x = 0; x < numberOfStrings; x++) {
      keysState[y][x] = { marker: false };
    }
  }
}
initKeysState();

// Show/hide note names
let showNotes = false;

// ==============================
// Simple Audio Synthesis
// ==============================
let audioContext;
let masterGainNode;

function initAudio() {
  audioContext = new (window.AudioContext || window.webkitAudioContext)();
  masterGainNode = audioContext.createGain();
  masterGainNode.gain.value = 0.1; // a bit quieter
  masterGainNode.connect(audioContext.destination);
}

function noteToFrequency(noteName, octave) {
  const noteIndex = NOTES.indexOf(noteName);
  if (noteIndex < 0) return 440; // fallback
  
  // semitones from A4 = 440Hz
  const A4_INDEX  = NOTES.indexOf("A"); // 9
  const A4_OCTAVE = 4;
  const semitones = (octave - A4_OCTAVE)*12 + (noteIndex - A4_INDEX);

  return 440 * Math.pow(2, semitones / 12);
}

function playNote(freq) {
  if (!audioContext) initAudio();
  
  const osc = audioContext.createOscillator();
  const gain = audioContext.createGain();
  
  osc.type = "sine";
  osc.frequency.value = freq;
  
  gain.gain.value = 0.5;
  
  osc.connect(gain);
  gain.connect(masterGainNode);

  osc.start();
  
  // quick envelope
  gain.gain.setValueAtTime(0.5, audioContext.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

  setTimeout(() => {
    osc.stop();
    osc.disconnect();
    gain.disconnect();
  }, 500);
}

// ==============================
// Note Calculation
// ==============================

// We want the bottom row (y=0) to be "startNote" (e.g., A0 for K24),
// and the top row (y=numberOfFrets-1) to be near the "endNote" (e.g., A5).
// We'll assume: each row going UP is +1 semitone, each string going RIGHT is +2 semitones.
function getSemitonesFromBase(x, y) {
  // y is row from bottom=0 to top=(numberOfFrets-1)
  // x is string from left=0 to right=(numberOfStrings-1)
  // So offset in semitones is: y + (2 * x)
  return y + 2*x;
}

function mod(n, m) {
  return ((n % m) + m) % m;
}

function getNoteName(x, y) {
  const baseIndex = NOTES.indexOf(BASE_NOTE); 
  const offset = getSemitonesFromBase(x, y);
  const newIndex = mod(baseIndex + offset, 12);
  return NOTES[newIndex];
}

function getNoteOctave(x, y) {
  const baseIndex = NOTES.indexOf(BASE_NOTE);
  const offset = getSemitonesFromBase(x, y);
  // total steps from base note
  const totalSemitones = baseIndex + offset;
  // how many 12-step blocks?
  const octaveShift = Math.floor(totalSemitones / 12);
  return BASE_OCTAVE + octaveShift;
}

function isBlackNote(n) {
  return n.includes("#");
}

// ==============================
// Draw the Tablature
// ==============================
function drawTablature() {
  // Update dimensions
  svgWidth  = stringSpacing * (numberOfStrings + 2);
  svgHeight = fretSpacing   * (numberOfFrets   + 2);

  const svg = document.getElementById("tablature");
  svg.innerHTML = ""; // clear

  svg.setAttribute("width",  svgWidth);
  svg.setAttribute("height", svgHeight);

  // White BG
  const bg = document.createElementNS("http://www.w3.org/2000/svg","rect");
  bg.setAttribute("width", "100%");
  bg.setAttribute("height","100%");
  bg.setAttribute("fill", "white");
  svg.appendChild(bg);

  // Main group with offset
  const g = document.createElementNS("http://www.w3.org/2000/svg","g");
  const offsetX = stringSpacing;
  const offsetY = fretSpacing;
  g.setAttribute("transform", `translate(${offsetX}, ${offsetY})`);
  svg.appendChild(g);

  // 1) Frets (horizontal lines) from bottom to top
  //    We'll keep the same "look" as your original, but invert the row so
  //    row=0 is physically at the bottom and row=numberOfFrets is at the top.
  for (let row = 0; row <= numberOfFrets; row++) {
    // old code used (row * fretSpacing + something)
    // now let's invert row to place it from bottom up:
    const lineY = (numberOfFrets - row) * fretSpacing 
                  + (row < numberOfFrets ? fretSpacing/2 : fretSpacing/2 + keyHeight);

    const line = document.createElementNS("http://www.w3.org/2000/svg","line");
    line.setAttribute("x1", 0);
    line.setAttribute("y1", lineY);
    line.setAttribute("x2", numberOfStrings * stringSpacing);
    line.setAttribute("y2", lineY);
    line.setAttribute("stroke", "#000");
    line.setAttribute("stroke-width", "1");
    g.appendChild(line);
  }

  // 2) Strings (vertical lines) left to right
  for (let x = 0; x < numberOfStrings; x++) {
    const line = document.createElementNS("http://www.w3.org/2000/svg","line");
    line.setAttribute("x1", x * stringSpacing + stringSpacing);
    line.setAttribute("y1", 0);
    line.setAttribute("x2", x * stringSpacing + stringSpacing);
    line.setAttribute("y2", numberOfFrets * fretSpacing + keyHeight);
    line.setAttribute("stroke", "#CCC");
    line.setAttribute("stroke-width", "1");
    g.appendChild(line);
  }

  // Optional border
  const borderRect = document.createElementNS("http://www.w3.org/2000/svg","rect");
  borderRect.setAttribute("x", 0.5);
  borderRect.setAttribute("y", 0.5);
  borderRect.setAttribute(
    "width", 
    (numberOfStrings * stringSpacing - 1 + stringSpacing)
  );
  borderRect.setAttribute(
    "height", 
    (numberOfFrets * fretSpacing + keyHeight - 1 + fretSpacing/2)
  );
  borderRect.setAttribute("fill", "transparent");
  borderRect.setAttribute("stroke", "black");
  g.appendChild(borderRect);

  // 3) Draw keys (rectangles) for each row/string
  //    bottom row is y=0, top row is y=numberOfFrets-1
  for (let y = 0; y < numberOfFrets; y++) {
    for (let x = 0; x < numberOfStrings; x++) {
      const noteName   = getNoteName(x, y);
      const noteOctave = getNoteOctave(x, y);
      const blackKey   = isBlackNote(noteName);

      // We'll invert the visual coordinate so y=0 is at bottom
      // The original code placed row y at y*fretSpacing + fretSpacing/2
      // so let's do lineY = (numberOfFrets - 1 - y)*fretSpacing + fretSpacing/2
      const visualY = (numberOfFrets - 1 - y)*fretSpacing + fretSpacing/2;
      const visualX = x*stringSpacing + stringSpacing;

      // A group for the key
      const keyGroup = document.createElementNS("http://www.w3.org/2000/svg","g");
      keyGroup.setAttribute("transform", `translate(${visualX}, ${visualY})`);
      keyGroup.style.cursor = "pointer";

      // The background rectangle
      const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
      rect.setAttribute("x", -7.5);
      rect.setAttribute("y", 0);
      rect.setAttribute("width", 15);
      rect.setAttribute("height", keyHeight);
      rect.setAttribute("stroke", "#666");
      rect.setAttribute("stroke-width", "1");
      rect.setAttribute("fill", blackKey ? "#999" : "#FFF");
      keyGroup.appendChild(rect);

      // Marker if toggled
      if (keysState[y][x].marker) {
        const circ = document.createElementNS("http://www.w3.org/2000/svg","circle");
        circ.setAttribute("cx", 0);
        circ.setAttribute("cy", 12.5);
        circ.setAttribute("r", 7);
        circ.setAttribute("fill", "rgba(0, 153, 255, 0.8)");
        keyGroup.appendChild(circ);
      }

      // Note label (if showNotes)
      if (showNotes) {
        const label = document.createElementNS("http://www.w3.org/2000/svg","text");
        label.setAttribute("x", 0);
        label.setAttribute("y", 8);
        label.setAttribute("fill", blackKey ? "#EEE" : "#555");
        label.setAttribute("font-size", "7");
        label.setAttribute("font-family", "Helvetica, Arial, sans-serif");
        label.setAttribute("text-anchor", "middle");
        label.textContent = noteName + noteOctave;
        keyGroup.appendChild(label);
      }

      // Click -> toggle marker & play
      keyGroup.addEventListener("click", () => {
        keysState[y][x].marker = !keysState[y][x].marker;
        playNote(noteToFrequency(noteName, noteOctave));
        drawTablature();
      });

      g.appendChild(keyGroup);
    }
  }
}

// ==============================
// Event Listeners
// ==============================
document.addEventListener("DOMContentLoaded", () => {
  drawTablature();

  // Model selection
  const modelSelect = document.getElementById("modelSelect");
  modelSelect.addEventListener("change", () => {
    const chosen = MODELS[modelSelect.value];
    currentModel     = chosen;
    numberOfStrings  = chosen.numberOfStrings;
    numberOfFrets    = chosen.numberOfFrets;
    BASE_NOTE        = chosen.startNote;
    BASE_OCTAVE      = chosen.startOctave;

    initKeysState();
    drawTablature();
  });

  // Toggle note names
  const toggleNotesBtn = document.getElementById("toggleNotesBtn");
  toggleNotesBtn.addEventListener("click", () => {
    showNotes = !showNotes;
    drawTablature();
  });

  // Clear all markers
  const resetMarkersBtn = document.getElementById("resetMarkersBtn");
  resetMarkersBtn.addEventListener("click", () => {
    initKeysState();
    drawTablature();
  });
});
</script>
</body>
</html>
