<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Harpejji Tablature Emulation (Plain JS + Tailwind)</title>
  <!-- Tailwind CSS (via CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 min-h-screen p-4 pb-[350px]">
<div class="max-w-5xl mx-auto bg-white rounded shadow p-4">
  <h1 class="text-2xl font-bold mb-4">HarpejjiÂ® Tablature (Plain JS)</h1>

  <!-- Controls -->
  <div class="flex flex-wrap items-center gap-4 mb-4">
    <div class="flex items-center gap-2">
      <label for="modelSelect" class="text-gray-700">Model:</label>
      <select 
        id="modelSelect"
        class="px-3 py-2 rounded border border-gray-300 bg-white focus:border-blue-500 focus:ring-1 focus:ring-blue-500 focus:outline-none min-w-[200px]"
      >
        <option value="K24">K24 (A0-A5, 24 strings)</option>
        <option value="G16">G16 (E2-C6, 16 strings)</option>
        <option value="G12">G12 (C2-C#5, 12 strings)</option>
      </select>
    </div>
    <button 
      id="toggleNotesBtn"
      class="px-4 py-2 rounded bg-blue-500 text-white hover:bg-blue-600"
    >
      Toggle Note Names
    </button>
    <button 
      id="resetMarkersBtn"
      class="px-4 py-2 rounded bg-red-500 text-white hover:bg-red-600"
    >
      Clear All Markers
    </button>
    <button 
      id="saveBtn"
      class="px-4 py-2 rounded bg-green-500 text-white hover:bg-green-600"
    >
      Save Selection
    </button>
    <button 
      id="loadBtn"
      class="px-4 py-2 rounded bg-yellow-500 text-white hover:bg-yellow-600"
    >
      Load Selection
    </button>
    <button 
      id="libraryBtn"
      class="px-4 py-2 rounded bg-purple-500 text-white hover:bg-purple-600"
    >
      Open Library
    </button>
    <span class="text-gray-600 text-sm">
      Click any key to toggle a marker and play its note.
    </span>
  </div>

  <!-- Our Tablature SVG -->
  <svg 
    id="tablature" 
    class="border border-gray-400"
  >
    <!-- Will be drawn dynamically via JavaScript -->
  </svg>
</div>

<!-- Library Slideover -->
<div id="librarySlideover" class="fixed inset-0 bg-gray-800 bg-opacity-75 hidden">
  <div class="absolute left-0 top-0 bottom-0 bg-white w-64 p-4 overflow-y-auto">
    <h2 class="text-xl font-bold mb-4">Library</h2>
    <button id="closeLibraryBtn" class="absolute top-2 right-2 px-2 py-1 rounded bg-red-500 text-white hover:bg-red-600">
      Close
    </button>
    <!-- Library Controls -->
    <div class="mb-4 flex flex-wrap gap-2">
      <button id="importBtn" class="px-3 py-1 rounded bg-green-500 text-white hover:bg-green-600">
        Import Files
      </button>
      <button id="saveLibraryBtn" class="px-3 py-1 rounded bg-blue-500 text-white hover:bg-blue-600">
        Save Library
      </button>
      <button id="loadLibraryBtn" class="px-3 py-1 rounded bg-yellow-500 text-white hover:bg-yellow-600">
        Load Library
      </button>
      <button id="clearLibraryBtn" class="px-3 py-1 rounded bg-gray-500 text-white hover:bg-gray-600">
        Clear Library
      </button>
    </div>
    <div id="libraryContent" class="space-y-4">
      <!-- Thumbnails and names of saved files will be dynamically added here -->
    </div>
  </div>
</div>

<!-- Sequencer -->
<div id="sequencer" class="fixed bottom-0 left-0 right-0 h-[300px] bg-gray-800 border-t border-gray-600">
    <div id="transport-controls" class="p-4 bg-gray-700 border-b border-gray-600 flex gap-2">
        <button id="play-btn" class="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600">
            Play
        </button>
        <button id="stop-btn" class="px-4 py-2 bg-yellow-500 text-white rounded hover:bg-yellow-600">
            Stop
        </button>
        <button id="record-btn" class="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600">
            Record
        </button>
        <button id="metronome-btn" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
            Metronome
        </button>
        <button id="save-seq-btn" class="px-4 py-2 bg-yellow-500 text-white rounded hover:bg-yellow-600">
            Save
        </button>
        <button id="load-seq-btn" class="px-4 py-2 bg-purple-500 text-white rounded hover:bg-purple-600">
            Load
        </button>
        <input type="file" id="load-seq-file" class="hidden" accept=".json">
    </div>
    
    <div class="flex h-[calc(100%-68px)]">
        <!-- Piano Roll -->
        <div class="w-[100px] bg-gray-900 h-full relative overflow-hidden">
            <div id="piano-roll-wrapper" class="absolute inset-0">
                <div id="piano-keys" class="w-full"></div>
            </div>
        </div>
        
        <!-- Sequencer Grid -->
        <div id="sequencer-grid" class="flex-1 relative overflow-auto bg-gray-900" 
             onscroll="document.querySelector('#piano-roll-wrapper').style.transform = `translateY(-${this.scrollTop}px)`">
            <div id="grid-content" class="absolute top-0 left-0"></div>
            <div id="playhead" class="absolute top-0 w-px bg-white opacity-50 pointer-events-none"></div>
        </div>
    </div>
</div>

<script>
// ==============================
// Configuration
// ==============================
const MODELS = {
  K24: {
    numberOfStrings: 24,
    numberOfFrets: 15,
    startNote: "A",
    startOctave: 0,
    endNote: "A",
    endOctave: 5
  },
  G16: {
    numberOfStrings: 16,
    numberOfFrets: 15,
    startNote: "E",
    startOctave: 2,
    endNote: "C",
    endOctave: 6
  },
  G12: {
    numberOfStrings: 12,
    numberOfFrets: 15,
    startNote: "C",
    startOctave: 2,
    endNote: "C#",
    endOctave: 5
  }
};

const fretSpacing = 30;   // vertical spacing in pixels
const stringSpacing = 30; // horizontal spacing in pixels
const keyHeight = 25;     // height of each key rectangle

// The notes array:
const NOTES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];

// Current model and configuration
let currentModel = MODELS.K24;
let numberOfFrets = currentModel.numberOfFrets;
let numberOfStrings = currentModel.numberOfStrings;
let BASE_NOTE = currentModel.startNote;
let BASE_OCTAVE = currentModel.startOctave;

// The drawing region will be sized accordingly:
let svgWidth = stringSpacing * (numberOfStrings + 2);
let svgHeight = fretSpacing * (numberOfFrets + 2);

// We keep an array of the "keys" states so we can toggle markers, etc.
let keysState = [];

function initKeysState() {
  keysState = [];
  for (let y = 0; y < numberOfFrets; y++) {
    keysState[y] = [];
    for (let x = 0; x < numberOfStrings; x++) {
      keysState[y][x] = { marker: false };
    }
  }
}

initKeysState();

// Whether to show note names or not:
let showNotes = false;

// ==============================
// Audio Synthesis Setup
// ==============================
let audioContext;
let masterGainNode;

function initAudio() {
  audioContext = new (window.AudioContext || window.webkitAudioContext)();
  masterGainNode = audioContext.createGain();
  masterGainNode.gain.value = 0.1; // Lower volume to avoid being too loud
  masterGainNode.connect(audioContext.destination);
}

// Convert note name and octave to frequency
function noteToFrequency(noteName, octave) {
  const noteIndex = NOTES.indexOf(noteName);
  if (noteIndex === -1) return 440; // Default to A4 if note not found
  
  // Calculate semitones from A4 (A4 = 440Hz)
  const A4_OCTAVE = 4;
  const A4_INDEX = NOTES.indexOf("A");
  const semitones = (octave - A4_OCTAVE) * 12 + (noteIndex - A4_INDEX);
  
  return 440 * Math.pow(2, semitones / 12);
}

// Play a note with the given frequency
function playNote(frequency) {
  if (!audioContext) initAudio();
  
  const oscillator = audioContext.createOscillator();
  const gainNode = audioContext.createGain();
  
  oscillator.type = 'sine';
  oscillator.frequency.value = frequency;
  
  gainNode.gain.value = 0.5;
  
  oscillator.connect(gainNode);
  gainNode.connect(masterGainNode);
  
  oscillator.start();
  
  // Envelope for a nicer sound
  gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
  gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
  
  // Stop and cleanup after the note is done
  setTimeout(() => {
    oscillator.stop();
    oscillator.disconnect();
    gainNode.disconnect();
  }, 500);
}

// ==============================
// Note Calculation Functions
// ==============================

// Calculate the total semitones from the base note for a given position
function getSemitonesFromBase(x, y) {
  // Each string (x) moves up by 2 semitones
  // Each fret (y) moves up by 1 semitone
  return (x * 2) + y;
}

// Get the note name for a given position
function getNoteName(x, y) {
  const baseNoteIndex = NOTES.indexOf(BASE_NOTE);
  const semitones = getSemitonesFromBase(x, y);
  
  const noteIndex = mod(baseNoteIndex + semitones, NOTES.length);
  return NOTES[noteIndex];
}

// Get the octave for a given position
function getNoteOctave(x, y) {
  const baseNoteIndex = NOTES.indexOf(BASE_NOTE);
  const semitones = getSemitonesFromBase(x, y);
  const totalSemitones = baseNoteIndex + semitones;
  
  const octaveShift = Math.floor(totalSemitones / NOTES.length);
  return BASE_OCTAVE + octaveShift;
}

// For convenience, black notes are those with "#" in them.
function isBlackNote(noteName) {
  return noteName.includes("#");
}

// Utility: positive mod (for wrapping note indices)
function mod(n, m) {
  return ((n % m) + m) % m;
}

// ==============================
// Main draw function for Harpejji Tablature
// ==============================
function drawTablature() {
  // Update dimensions based on current model
  svgWidth = stringSpacing * (numberOfStrings + 2);
  svgHeight = fretSpacing * (numberOfFrets + 2);
  
  const svg = document.getElementById("tablature");
  // Clear previous children
  svg.innerHTML = "";

  // Set the SVG size
  svg.setAttribute("width", svgWidth);
  svg.setAttribute("height", svgHeight);

  // Draw a white background
  const bg = document.createElementNS("http://www.w3.org/2000/svg","rect");
  bg.setAttribute("width", "100%");
  bg.setAttribute("height","100%");
  bg.setAttribute("fill", "white");
  svg.appendChild(bg);

  // Group for everything
  const g = document.createElementNS("http://www.w3.org/2000/svg","g");
  // We'll shift it a bit so there's some margin
  const offsetX = stringSpacing;
  const offsetY = fretSpacing;
  g.setAttribute("transform", `translate(${offsetX}, ${offsetY})`);
  svg.appendChild(g);

  // 1) Draw frets (horizontal lines)
  for (let y = 0; y <= numberOfFrets; y++) {
    const line = document.createElementNS("http://www.w3.org/2000/svg","line");
    line.setAttribute("x1", 0);
    line.setAttribute("y1", y * fretSpacing + (y < numberOfFrets ? fretSpacing/2 : fretSpacing/2 + keyHeight));
    line.setAttribute("x2", (numberOfStrings) * stringSpacing);
    line.setAttribute("y2", y * fretSpacing + (y < numberOfFrets ? fretSpacing/2 : fretSpacing/2 + keyHeight));
    line.setAttribute("stroke", "#000");
    line.setAttribute("stroke-width", "1");
    g.appendChild(line);
  }

  // 2) Draw strings (vertical lines)
  for (let x = 0; x < numberOfStrings; x++) {
    const line = document.createElementNS("http://www.w3.org/2000/svg","line");
    line.setAttribute("x1", x * stringSpacing + stringSpacing);
    line.setAttribute("y1", 0);
    line.setAttribute("x2", x * stringSpacing + stringSpacing);
    line.setAttribute("y2", numberOfFrets * fretSpacing + keyHeight);
    line.setAttribute("stroke", "#CCC");
    line.setAttribute("stroke-width", "1");
    g.appendChild(line);
  }

  // 3) Optional border around the entire zone
  const borderRect = document.createElementNS("http://www.w3.org/2000/svg","rect");
  borderRect.setAttribute("x", 0.5);
  borderRect.setAttribute("y", 0.5);
  borderRect.setAttribute("width",  (numberOfStrings) * stringSpacing - 1 + stringSpacing);
  borderRect.setAttribute("height", numberOfFrets * fretSpacing + keyHeight - 1 + fretSpacing/2);
  borderRect.setAttribute("fill", "transparent");
  borderRect.setAttribute("stroke", "black");
  g.appendChild(borderRect);

  // 4) Draw the keys (rectangles) for each fret/string intersection
  for (let y = 0; y < numberOfFrets; y++) {
    for (let x = 0; x < numberOfStrings; x++) {
      const noteName = getNoteName(x, y);
      const octave   = getNoteOctave(x, y);
      const blackKey = isBlackNote(noteName);

      const keyGroup = document.createElementNS("http://www.w3.org/2000/svg","g");
      keyGroup.setAttribute(
        "transform", 
        `translate(${x * stringSpacing + stringSpacing}, ${y * fretSpacing + fretSpacing/2})`
      );

      // The background rectangle
      const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
      rect.setAttribute("x", -7.5);
      rect.setAttribute("y", 0);
      rect.setAttribute("width", 15);
      rect.setAttribute("height", keyHeight);
      rect.setAttribute("stroke", "#666");
      rect.setAttribute("stroke-width", "1");
      rect.setAttribute("fill", blackKey ? "#999" : "#FFF");
      keyGroup.appendChild(rect);

      // Marker if toggled on
      if (keysState[y] && keysState[y][x] && keysState[y][x].marker) {
        const circ = document.createElementNS("http://www.w3.org/2000/svg","circle");
        circ.setAttribute("cx", 0);
        circ.setAttribute("cy", 12.5);
        circ.setAttribute("r", 7);
        circ.setAttribute("fill", "rgba(0, 153, 255, 0.8)");
        keyGroup.appendChild(circ);
      }

      // If showNotes, place a small label
      if (showNotes) {
        const label = document.createElementNS("http://www.w3.org/2000/svg","text");
        label.setAttribute("x", "0");
        label.setAttribute("y", blackKey ? "8" : "8");
        label.setAttribute("fill", blackKey ? "#EEE" : "#555");
        label.setAttribute("font-size", "7");
        label.setAttribute("font-family", "Helvetica, Arial, sans-serif");
        label.setAttribute("text-anchor", "middle");
        label.textContent = noteName + octave;
        keyGroup.appendChild(label);
      }

      // Click events
      keyGroup.style.cursor = "pointer";
      keyGroup.addEventListener("mousedown", () => {
        // Toggle marker
        if (!keysState[y]) keysState[y] = [];
        if (!keysState[y][x]) keysState[y][x] = { marker: false };
        keysState[y][x].marker = !keysState[y][x].marker;
        
        // Play the note
        const frequency = noteToFrequency(noteName, octave);
        playNote(frequency);

        // Record note if recording is active
        startNoteRecording(x, y);
        
        // Redraw
        drawTablature();
      });

      keyGroup.addEventListener("mouseup", () => {
        stopNoteRecording(x, y);
      });

      keyGroup.addEventListener("mouseleave", () => {
        stopNoteRecording(x, y);
      });

      g.appendChild(keyGroup);
    }
  }
}

// ==============================
// Save and Load Functions (Tablature)
// ==============================
function saveSelection() {
  const fileName = prompt("Enter a name for your selection:", "My Selection");
  if (!fileName) return;

  // Create a canvas to capture the SVG as an image
  const svg = document.getElementById("tablature");
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  const svgData = new XMLSerializer().serializeToString(svg);
  const img = new Image();
  
  img.onload = function() {
    canvas.width = svg.width.baseVal.value;
    canvas.height = svg.height.baseVal.value;
    ctx.drawImage(img, 0, 0);
    
    // Create a complete selection object with all necessary data
    const data = {
      name: fileName,
      model: modelSelect.value,
      keysState: keysState,
      image: canvas.toDataURL("image/png"),
      timestamp: new Date().toISOString(),
      modelData: {
        numberOfStrings: currentModel.numberOfStrings,
        numberOfFrets: currentModel.numberOfFrets,
        startNote: currentModel.startNote,
        startOctave: currentModel.startOctave,
        endNote: currentModel.endNote,
        endOctave: currentModel.endOctave
      }
    };

    // Save to localStorage
    const savedSelections = JSON.parse(localStorage.getItem('harpejjiSelections') || '[]');
    savedSelections.push(data);
    localStorage.setItem('harpejjiSelections', JSON.stringify(savedSelections));

    // Save individual selection file
    const blob = new Blob([JSON.stringify(data)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${fileName}.json`;
    a.click();
    URL.revokeObjectURL(url);

    // Refresh library
    populateLibrary();
  };

  img.src = 'data:image/svg+xml;base64,' + btoa(svgData);
}

function loadSelection(data) {
  const modelSelect = document.getElementById("modelSelect");
  modelSelect.value = data.model;
  
  // Use stored model data if available
  if (data.modelData) {
    currentModel = data.modelData;
  } else {
    currentModel = MODELS[data.model];
  }
  
  numberOfStrings = currentModel.numberOfStrings;
  numberOfFrets = currentModel.numberOfFrets;
  BASE_NOTE = currentModel.startNote;
  BASE_OCTAVE = currentModel.startOctave;
  
  keysState = data.keysState;
  
  drawTablature();
  // Also refresh the piano roll for the new range
  drawPianoRoll();
  drawSequencerGrid();

  toggleLibrary();
}

function handleFileLoad() {
  const input = document.createElement("input");
  input.type = "file";
  input.accept = "application/json";
  input.onchange = (event) => {
    const file = event.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        const data = JSON.parse(e.target.result);
        loadSelection(data);
      };
      reader.readAsText(file);
    }
  };
  input.click();
}

// ==============================
// Library Slideover Functions
// ==============================
function toggleLibrary() {
  const slideover = document.getElementById("librarySlideover");
  slideover.classList.toggle("hidden");
}

function populateLibrary() {
  const libraryContent = document.getElementById("libraryContent");
  libraryContent.innerHTML = ""; // Clear existing content
  
  const savedSelections = JSON.parse(localStorage.getItem('harpejjiSelections') || '[]');
  
  if (savedSelections.length === 0) {
    libraryContent.innerHTML = '<p class="text-gray-500 text-center">No saved selections yet</p>';
    return;
  }

  savedSelections.forEach((selection, index) => {
    const div = document.createElement("div");
    div.className = "relative p-2 border rounded hover:bg-gray-100";
    div.innerHTML = `
      <button class="absolute top-2 right-2 px-2 py-1 rounded bg-red-500 text-white hover:bg-red-600 text-xs delete-btn">
        Delete
      </button>
      <div class="cursor-pointer selection-content">
        <img src="${selection.image}" alt="${selection.name}" class="w-full h-32 object-contain mb-2 bg-white">
        <div class="text-sm">
          <span class="block text-center font-bold">${selection.name}</span>
          <span class="block text-center text-gray-500">${selection.model}</span>
          <span class="block text-center text-gray-400 text-xs">${new Date(selection.timestamp).toLocaleDateString()}</span>
        </div>
      </div>
    `;

    // Load on click
    div.querySelector('.selection-content').addEventListener('click', () => loadSelection(selection));
    // Delete
    div.querySelector('.delete-btn').addEventListener('click', (e) => {
      e.stopPropagation();
      deleteSelection(index);
    });

    libraryContent.appendChild(div);
  });
}

function deleteSelection(index) {
  if (!confirm('Are you sure you want to delete this selection?')) return;
  const savedSelections = JSON.parse(localStorage.getItem('harpejjiSelections') || '[]');
  savedSelections.splice(index, 1);
  localStorage.setItem('harpejjiSelections', JSON.stringify(savedSelections));
  populateLibrary();
}

function importFiles() {
  const input = document.createElement("input");
  input.type = "file";
  input.accept = "application/json";
  input.multiple = true;
  input.onchange = (event) => {
    const files = event.target.files;
    if (files.length === 0) return;

    const savedSelections = JSON.parse(localStorage.getItem('harpejjiSelections') || '[]');
    let processed = 0;

    Array.from(files).forEach(file => {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          savedSelections.push(data);
          processed++;

          if (processed === files.length) {
            localStorage.setItem('harpejjiSelections', JSON.stringify(savedSelections));
            populateLibrary();
          }
        } catch (error) {
          console.error('Error importing file:', error);
        }
      };
      reader.readAsText(file);
    });
  };
  input.click();
}

function saveLibrary() {
  const savedSelections = JSON.parse(localStorage.getItem('harpejjiSelections') || '[]');
  if (savedSelections.length === 0) {
    alert('No selections to save');
    return;
  }

  // Ensure each selection has complete model data
  const completeLibrary = savedSelections.map(selection => {
    if (!selection.modelData) {
      const model = MODELS[selection.model];
      selection.modelData = {
        numberOfStrings: model.numberOfStrings,
        numberOfFrets: model.numberOfFrets,
        startNote: model.startNote,
        startOctave: model.startOctave,
        endNote: model.endNote,
        endOctave: model.endOctave
      };
    }
    return selection;
  });

  const blob = new Blob([JSON.stringify(completeLibrary)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'harpejji_library.json';
  a.click();
  URL.revokeObjectURL(url);
}

function loadLibrary() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'application/json';
  input.onchange = (event) => {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const library = JSON.parse(e.target.result);
        if (Array.isArray(library)) {
          localStorage.setItem('harpejjiSelections', JSON.stringify(library));
          populateLibrary();
        } else {
          throw new Error('Invalid library file format');
        }
      } catch (error) {
        alert('Error loading library: ' + error.message);
      }
    };
    reader.readAsText(file);
  };
  input.click();
}

// ==============================
// Sequencer Configuration
// ==============================
const SEQUENCER_CONFIG = {
    pixelsPerBeat: 100,
    beatsPerBar: 4,
    bpm: 120,
    totalBars: 16,
    noteHeight: 20,
};

// Sequencer State
let isPlaying = false;
let isRecording = false;
let metronomeEnabled = false;
let currentBeat = 0;
let recordedNotes = [];
let playheadPosition = 0;
let audioStartTime = 0;
let activeNotes = new Map(); // Track currently pressed notes for recording

// We'll build a global map of note->index and a sorted array, so that
// the piano roll and recording always match properly.
let globalSortedNotes = [];         // In descending pitch order
let globalNoteToIndexMap = new Map(); // Map "G4" -> row index

// ==============================
// Metronome
// ==============================
let metronomeContext;
let metronomeGain;

function initMetronome() {
    if (!metronomeContext) {
        metronomeContext = new (window.AudioContext || window.webkitAudioContext)();
        metronomeGain = metronomeContext.createGain();
        metronomeGain.gain.value = 0.3;
        metronomeGain.connect(metronomeContext.destination);
    }
}

function playMetronomeSound() {
    const osc = metronomeContext.createOscillator();
    const clickGain = metronomeContext.createGain();
    
    osc.frequency.value = 1000;
    clickGain.gain.value = 0;
    
    osc.connect(clickGain);
    clickGain.connect(metronomeGain);
    
    osc.start();
    clickGain.gain.setValueAtTime(1, metronomeContext.currentTime);
    clickGain.gain.exponentialRampToValueAtTime(0.001, metronomeContext.currentTime + 0.05);
    
    osc.stop(metronomeContext.currentTime + 0.05);
}

// ==============================
// Build a sorted list of all possible notes in the current model
// in descending pitch order, plus a map of note -> row index
// ==============================
function buildSortedNotesMapping() {
  // Collect every note in an array
  let noteObjects = [];
  for (let y = 0; y < numberOfFrets; y++) {
    for (let x = 0; x < numberOfStrings; x++) {
      const noteName = getNoteName(x, y);
      const octave   = getNoteOctave(x, y);

      // Convert to a numeric pitch so we can sort reliably
      const pitch = getMIDINumber(noteName, octave);
      noteObjects.push({ noteName, octave, pitch });
    }
  }

  // Remove duplicates. We'll use a Map keyed by pitch
  // (If your instrument truly doesn't have duplicates, this is mostly precaution.)
  let pitchMap = new Map();
  noteObjects.forEach(n => {
    // If two positions yield the same pitch, we only need one row in the piano roll
    if (!pitchMap.has(n.pitch)) {
      pitchMap.set(n.pitch, n);
    }
  });

  // Convert map back to an array
  let uniqueNotes = Array.from(pitchMap.values());

  // Sort in descending pitch
  uniqueNotes.sort((a, b) => b.pitch - a.pitch);

  // Now build global arrays and maps
  globalSortedNotes = uniqueNotes; 
  globalNoteToIndexMap.clear();

  // Assign each note a row index
  uniqueNotes.forEach((noteObj, index) => {
    const fullName = noteObj.noteName + noteObj.octave;
    globalNoteToIndexMap.set(fullName, index);
  });
}

// Helper to convert "C4" -> MIDI-like number for sorting
function getMIDINumber(noteName, octave) {
  // MIDI for C4 is 60
  // general formula: midiNumber = (octave + 1) * 12 + noteIndex
  const noteIndex = NOTES.indexOf(noteName);
  return (octave + 1) * 12 + noteIndex;
}

// ==============================
// Draw piano roll (left side labels) using globalSortedNotes
// ==============================
function drawPianoRoll() {
  // Rebuild the note listing in case model changed
  buildSortedNotesMapping();

  const pianoKeysContainer = document.getElementById('piano-keys');
  pianoKeysContainer.innerHTML = '';
  
  // For each unique pitch in descending order:
  globalSortedNotes.forEach((noteObj, index) => {
    const { noteName, octave } = noteObj;
    const isBlack = isBlackNote(noteName);

    const key = document.createElement('div');
    // We fix the height to SEQUENCER_CONFIG.noteHeight
    key.style.height = `${SEQUENCER_CONFIG.noteHeight}px`;
    key.className = `border-b border-gray-700 flex items-center px-2 text-xs 
                     ${isBlack ? 'bg-gray-800' : 'bg-gray-700'} 
                     text-white`;
    key.textContent = noteName + octave;

    pianoKeysContainer.appendChild(key);
  });

  // Set container height to match the total number of unique notes
  const totalHeight = globalSortedNotes.length * SEQUENCER_CONFIG.noteHeight;
  pianoKeysContainer.style.height = `${totalHeight}px`;
}

// ==============================
// Draw sequencer grid
// ==============================
function drawSequencerGrid() {
  const gridContent = document.getElementById('grid-content');
  const playhead = document.getElementById('playhead');
  gridContent.innerHTML = '';
  
  // The total number of unique notes is globalSortedNotes.length
  const totalNotes = globalSortedNotes.length;
  // The total grid width
  const totalWidth = SEQUENCER_CONFIG.pixelsPerBeat * SEQUENCER_CONFIG.beatsPerBar * SEQUENCER_CONFIG.totalBars;
  const totalHeight = totalNotes * SEQUENCER_CONFIG.noteHeight;
  
  gridContent.style.width = `${totalWidth}px`;
  gridContent.style.height = `${totalHeight}px`;
  playhead.style.height = `${totalHeight}px`;
  
  // Draw vertical grid lines (each beat)
  for (let i = 0; i <= SEQUENCER_CONFIG.totalBars * SEQUENCER_CONFIG.beatsPerBar; i++) {
    const line = document.createElement('div');
    line.className = `absolute top-0 w-px h-full ${i % SEQUENCER_CONFIG.beatsPerBar === 0 ? 'bg-gray-500' : 'bg-gray-700'}`;
    line.style.left = `${i * SEQUENCER_CONFIG.pixelsPerBeat}px`;
    gridContent.appendChild(line);
  }
  
  // Draw horizontal grid lines for each note row
  for (let i = 0; i <= totalNotes; i++) {
    const line = document.createElement('div');
    line.className = 'absolute left-0 right-0 h-px bg-gray-700';
    line.style.top = `${i * SEQUENCER_CONFIG.noteHeight}px`;
    gridContent.appendChild(line);
  }
  
  // Draw recorded notes
  recordedNotes.forEach(note => {
    const noteElement = document.createElement('div');
    noteElement.className = 'absolute bg-blue-500 opacity-75 rounded';
    // Convert startTime to pixels
    const leftPx = note.startTime * (SEQUENCER_CONFIG.bpm / 60) * SEQUENCER_CONFIG.pixelsPerBeat;
    const widthPx = note.duration * (SEQUENCER_CONFIG.bpm / 60) * SEQUENCER_CONFIG.pixelsPerBeat;
    const topPx = note.noteIndex * SEQUENCER_CONFIG.noteHeight;

    noteElement.style.left = `${leftPx}px`;
    noteElement.style.top = `${topPx}px`;
    noteElement.style.width = `${widthPx}px`;
    noteElement.style.height = `${SEQUENCER_CONFIG.noteHeight}px`;

    gridContent.appendChild(noteElement);
  });
}

// ==============================
// Handle note recording
// We look up the note's row index via globalNoteToIndexMap
// ==============================
function startNoteRecording(x, y) {
  if (!isRecording) return;
  
  const noteName = getNoteName(x, y);
  const octave = getNoteOctave(x, y);
  const fullName = noteName + octave;
  
  // Which row in the piano roll is this note?
  const noteIndex = globalNoteToIndexMap.get(fullName);
  if (noteIndex === undefined) return;

  const startTime = audioContext.currentTime - audioStartTime;
  
  activeNotes.set(fullName, {
    noteName,
    octave,
    noteIndex,
    startTime
  });
}

function stopNoteRecording(x, y) {
  if (!isRecording) return;
  
  const noteName = getNoteName(x, y);
  const octave = getNoteOctave(x, y);
  const fullName = noteName + octave;
  
  if (activeNotes.has(fullName)) {
    const activeNote = activeNotes.get(fullName);
    const endTime = audioContext.currentTime - audioStartTime;
    const duration = endTime - activeNote.startTime;

    recordedNotes.push({
      ...activeNote,
      duration,
      isPlaying: false
    });
    
    activeNotes.delete(fullName);
    drawSequencerGrid();
  }
}

// ==============================
// Playhead / Main Sequencer Loop
// ==============================
function updatePlayhead() {
    if (!isPlaying) return;
    
    const currentTime = audioContext.currentTime - audioStartTime;
    playheadPosition = (currentTime * SEQUENCER_CONFIG.bpm / 60) * SEQUENCER_CONFIG.pixelsPerBeat;
    
    const playhead = document.getElementById('playhead');
    playhead.style.left = `${playheadPosition}px`;
    
    // Auto-scroll the grid
    const grid = document.getElementById('sequencer-grid');
    const gridRect = grid.getBoundingClientRect();
    if (playheadPosition > grid.scrollLeft + gridRect.width * 0.7) {
        grid.scrollLeft = playheadPosition - gridRect.width * 0.3;
    }
    
    // Play recorded notes
    recordedNotes.forEach(note => {
        const noteStartTime = note.startTime;
        const noteEndTime = noteStartTime + note.duration;
        
        if (currentTime >= noteStartTime && currentTime < noteEndTime && !note.isPlaying) {
            // Start playing the note
            const frequency = noteToFrequency(note.noteName, note.octave);
            playNote(frequency);
            note.isPlaying = true;
        } else if (currentTime >= noteEndTime && note.isPlaying) {
            // Stop playing the note
            note.isPlaying = false;
        }
    });
    
    // Play metronome if enabled
    if (metronomeEnabled) {
        const beatPosition = Math.floor(currentTime * SEQUENCER_CONFIG.bpm / 60);
        if (beatPosition > currentBeat) {
            currentBeat = beatPosition;
            playMetronomeSound();
        }
    }
    
    requestAnimationFrame(updatePlayhead);
}

// ==============================
// Sequencer Transport Controls
// ==============================
function togglePlay() {
    if (!audioContext) initAudio();
    if (!metronomeContext) initMetronome();
    
    isPlaying = true;
    const playBtn = document.getElementById('play-btn');
    playBtn.classList.add('bg-green-600');
    
    audioStartTime = audioContext.currentTime;
    currentBeat = 0;
    updatePlayhead();
}

function stopPlayback() {
    isPlaying = false;
    isRecording = false;
    const playBtn = document.getElementById('play-btn');
    const recordBtn = document.getElementById('record-btn');
    playBtn.classList.remove('bg-green-600');
    recordBtn.classList.remove('bg-red-600');
    
    // Reset playhead position
    const playhead = document.getElementById('playhead');
    playhead.style.left = '0';
    playheadPosition = 0;
    
    // Reset all playing notes
    recordedNotes.forEach(note => {
        note.isPlaying = false;
    });
}

function toggleRecord() {
    isRecording = !isRecording;
    const recordBtn = document.getElementById('record-btn');
    recordBtn.classList.toggle('bg-red-600');
    
    if (isRecording && !isPlaying) {
        togglePlay();
    }
}

function toggleMetronome() {
    metronomeEnabled = !metronomeEnabled;
    const metronomeBtn = document.getElementById('metronome-btn');
    metronomeBtn.classList.toggle('bg-blue-600');
}

function saveSequence() {
    const fileName = prompt('Enter a name for your sequence:', 'My Sequence');
    if (!fileName) return;
    
    const data = {
        name: fileName,
        bpm: SEQUENCER_CONFIG.bpm,
        notes: recordedNotes,
        timestamp: new Date().toISOString()
    };
    
    const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${fileName}.json`;
    a.click();
    URL.revokeObjectURL(url);
}

function loadSequence() {
    const input = document.getElementById('load-seq-file');
    input.onchange = (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    SEQUENCER_CONFIG.bpm = data.bpm;
                    recordedNotes = data.notes || [];
                    
                    // Stop any current playback/record
                    stopPlayback();
                    drawSequencerGrid();
                } catch (error) {
                    console.error('Error loading sequence:', error);
                    alert('Error loading sequence file');
                }
            };
            reader.readAsText(file);
        }
    };
    input.click();
}

// ==============================
// DOMContentLoaded
// ==============================
document.addEventListener("DOMContentLoaded", () => {
    // Initialize the tablature
    drawTablature();
    
    // Initialize the piano roll and sequencer grid
    drawPianoRoll();
    drawSequencerGrid();
    
    // Sequencer transport event listeners
    document.getElementById('play-btn').addEventListener('click', togglePlay);
    document.getElementById('stop-btn').addEventListener('click', stopPlayback);
    document.getElementById('record-btn').addEventListener('click', toggleRecord);
    document.getElementById('metronome-btn').addEventListener('click', toggleMetronome);
    document.getElementById('save-seq-btn').addEventListener('click', saveSequence);
    document.getElementById('load-seq-btn').addEventListener('click', loadSequence);

    // Model selection change
    const modelSelect = document.getElementById("modelSelect");
    modelSelect.addEventListener("change", () => {
        currentModel = MODELS[modelSelect.value];
        numberOfStrings = currentModel.numberOfStrings;
        numberOfFrets = currentModel.numberOfFrets;
        BASE_NOTE = currentModel.startNote;
        BASE_OCTAVE = currentModel.startOctave;
        
        initKeysState();
        drawTablature();
        drawPianoRoll();
        drawSequencerGrid();
    });

    // Toggle note-name display
    const toggleNotesBtn = document.getElementById("toggleNotesBtn");
    toggleNotesBtn.addEventListener("click", () => {
        showNotes = !showNotes;
        drawTablature();
    });

    // Clear all markers
    const resetMarkersBtn = document.getElementById("resetMarkersBtn");
    resetMarkersBtn.addEventListener("click", () => {
        initKeysState();
        drawTablature();
    });

    // Save selection
    const saveBtn = document.getElementById("saveBtn");
    saveBtn.addEventListener("click", saveSelection);

    // Load selection from file
    const loadBtn = document.getElementById("loadBtn");
    loadBtn.addEventListener("click", handleFileLoad);

    // Library Slideover
    const closeLibraryBtn = document.getElementById("closeLibraryBtn");
    closeLibraryBtn.addEventListener("click", toggleLibrary);
    populateLibrary();
    
    const libraryBtn = document.getElementById("libraryBtn");
    libraryBtn.addEventListener("click", toggleLibrary);

    // Library management buttons
    document.getElementById("importBtn").addEventListener("click", importFiles);
    document.getElementById("saveLibraryBtn").addEventListener("click", saveLibrary);
    document.getElementById("loadLibraryBtn").addEventListener("click", loadLibrary);
    document.getElementById("clearLibraryBtn").addEventListener("click", () => {
        if (confirm('Are you sure you want to clear the library? This will hide all selections but not delete them.')) {
            libraryContent.innerHTML = '<p class="text-gray-500 text-center">No saved selections yet</p>';
        }
    });
});
</script>
</body>
</html>
